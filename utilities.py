"""
Author: Maxwell Buckmire-Monro
maxwell.monro@kcl.ac.uk
"""

import torch
import torch.nn as nn
import numpy as np
import matplotlib.pyplot as plt
from torch_pet.system_model.pet_system_model import PETSystemModel
from torch_pet.system_model.differentiable_functions import ForwardModel, BackwardModel


class DictDataset(torch.utils.data.Dataset):
    """
    Custom PyTorch dataset for handling list of dictionaries for dataloader.

    Parameters
    ----------
    dict_list: list
        List of dictionary objects which form dataset.
    """
    def __init__(self, dict_list: list):
        self.dict_list = dict_list

    def __getitem__(self, idx):
        return self.dict_list[idx]

    def __len__(self):
        return len(self.dict_list)


def em_update(img: torch.Tensor, sino: torch.Tensor, sens_img: torch.Tensor,
    system_model: PETSystemModel):
    """
    Function which computes a single EM update.

    Parameters
    ----------
    img: torch.Tensor
        Current image estimate tensor.

    sino: torch.Tensor
        Measured sinogram tensor.

    sens_img: torch.Tensor
        Sensitivity image of system model. Precomputed to save time.

    system_model: PETSystemModel
        PETSystemModel object which defines imaging system.

    Returns
    -------
    torch.Tensor
        New image estimate tensor generated by EM update.
    """
    forward_model = ForwardModel.apply
    backward_model = BackwardModel.apply
    device = 'cpu' if img.get_device() == -1 else img.get_device()
    batch_size = img.shape[0]
    n_realisations = img.shape[2]
    sens_img = sens_img.view(1, 1, 1, img.shape[-2], img.shape[-1])
    sens_img = sens_img.repeat(batch_size, 1, n_realisations, 1, 1)
    forwardprojection = torch.zeros_like(sino).to(device).float()
    for b in range(batch_size):
        for r in range(n_realisations):
            forwardprojection[b, 0, r, :, :] = forward_model(img[b, 0, r, :, :], system_model)
    fp_mask = (forwardprojection != 0)
    ratio_sino = torch.zeros_like(sino).to(device).float()
    ratio_sino[fp_mask] = sino [fp_mask] / forwardprojection[fp_mask]
    backprojection = torch.zeros_like(img).to(device).float()
    for b in range(batch_size):
        for r in range(n_realisations):
            backprojection[b, 0, r, :, :] = backward_model(ratio_sino[b, 0, r, :, :], system_model)
    bp_mask = (backprojection != 0)
    updated_img = torch.zeros_like(img).to(device).float()
    updated_img[bp_mask] = \
        backprojection[bp_mask] * img[bp_mask] / sens_img[bp_mask]
    return updated_img


def batch_rmse(recons: torch.Tensor, targets: torch.Tensor):
    """
    Function to compute RMSE in comparison to a target image for a given batch
    of reconstructed images, each with multiple realisations.

    Parameters
    ----------
    recons: torch.Tensor
        Stack of reconstructed images.

    targets: torch.Tensor
        Stack of target images.

    Returns
    -------
    float, float, float
        RMSE, bias and standard deviation of recons compared to targets.
    """
    recons = recons.detach().cpu().numpy()
    targets = targets.detach().cpu().numpy()
    mean_img = np.mean(recons, axis=2)
    repeat_mean_img = np.repeat(mean_img[:, :, np.newaxis, :, :],
        recons.shape[2], axis=2)
    bias = np.sqrt(np.sum(np.square(mean_img - targets), axis=(1, 2, 3)) /
        np.sum(np.square(targets), axis=(1, 2, 3)))
    std_dev = np.sqrt(np.mean(np.sum(np.square(repeat_mean_img - recons),
        axis=(1, 3, 4)), axis=1) / np.sum(np.square(targets), axis=(1, 2, 3)))
    batch_size = recons.shape[0]
    return np.array([[np.sqrt(bias[b]**2 + std_dev[b]**2), bias[b], std_dev[b]] for b in range(batch_size)])


def plot_test_results(test_results):
    """
    Function for plotting test results from dictionary.

    Parameters
    ----------
    test_results: dict
        Dictionary of test results.
    """
    ld_counts = torch.mean(test_results['LD_counts']).numpy()
    best_rmse_wrt_ref = np.round(test_results['best_rmse_wrt_ref'] * 100, 3)
    best_rmse_wrt_gt = np.round(test_results['best_rmse_wrt_gt'] * 100, 3)
    final_rmse_wrt_ref = np.round(test_results['final_rmse_wrt_ref'] * 100, 3)
    final_rmse_wrt_gt = np.round(test_results['final_rmse_wrt_gt'] * 100, 3)
    final_recon_img = test_results['final_recon'][0, 0, 20:-20, 20:-20]
    ground_truth = test_results['pet_gt'][0, 20:-20, 20:-20]
    rmse_wrt_ref = test_results['rmse_wrt_ref']
    rmse_wrt_gt = test_results['rmse_wrt_gt']
    n_mods = len(rmse_wrt_ref)

    fig, ax = plt.subplots(figsize=(16, 10), nrows=1, ncols=2)
    ax[0].imshow(final_recon_img, vmax=ground_truth.max(), cmap='Greys')
    ax[0].set_title(
        'Final reconstruction\nRMSE wrt HQ Ref = {}\nRMSE wrt GT = {}\nCounts = {}k'.format(
            final_rmse_wrt_ref, final_rmse_wrt_gt, int(round(ld_counts / 1e3))))
    ax[1].plot(np.arange(n_mods) + 1, rmse_wrt_ref, label='HQ Reference')
    ax[1].plot(np.arange(n_mods) + 1, rmse_wrt_gt, label='Ground Truth')
    ax[1].set_xlim(left=1)
    ax[1].set_ylim(bottom=0)
    ax[1].legend(title='wrt')
    ax[1].set_title(
        'rmse vs. module\nBest rmse wrt HQ Ref = {}\nBest rmse wrt GT = {}'.format(
            best_rmse_wrt_ref, best_rmse_wrt_gt))
    plt.show()
